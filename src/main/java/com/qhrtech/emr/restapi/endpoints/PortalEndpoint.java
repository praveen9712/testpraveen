
package com.qhrtech.emr.restapi.endpoints;

import com.qhrtech.emr.accuro.api.office.DefaultOfficeManager;
import com.qhrtech.emr.accuro.api.office.OfficeManager;
import com.qhrtech.emr.accuro.model.demographics.Office;
import com.qhrtech.emr.accuro.model.exceptions.ProtossException;
import com.qhrtech.emr.accuro.model.exceptions.dataaccess.DataAccessException;
import com.qhrtech.emr.accuro.model.patient.Patient;
import com.qhrtech.emr.restapi.models.dto.AddressDto;
import com.qhrtech.emr.restapi.models.dto.EmailDto;
import com.qhrtech.emr.restapi.models.endpoints.Error;
import com.qhrtech.emr.restapi.models.endpoints.PortalToken;
import com.qhrtech.emr.restapi.security.AccuroOAuthClient;
import com.qhrtech.emr.restapi.security.AccuroOAuthClientLookup;
import com.qhrtech.emr.restapi.security.datasource.DataSourceService;
import com.qhrtech.emr.restapi.services.AccuroPatientService;
import com.qhrtech.emr.restapi.util.JwtUtil;
import com.webcohesion.enunciate.metadata.Facet;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.sql.DataSource;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response.Status;
import org.apache.commons.lang.StringUtils;
import org.jose4j.jwt.consumer.InvalidJwtException;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.endpoint.TokenEndpoint;
import org.springframework.stereotype.Component;
import org.springframework.web.HttpRequestMethodNotSupportedException;

/**
 * This <code>PortalEndpoint</code> collection is designed to expose the patient-level
 * authentication grant.
 *
 * @RequestHeader Authorization Client credentials grant
 *
 * @HTTP 200 Request successful
 * @HTTP 401 Consumer unauthorized
 * @HTTP 401 Insufficient scope
 * @HTTP 500 Unable to process JWT Token
 */
@Component
@Path("/v1/portal")
@PreAuthorize("#oauth2.isClient()")
@Facet("patient-portal")
@Tag(name = "Portal Endpoints", description = "Exposes portal endpoints")
public class PortalEndpoint extends AbstractEndpoint {

  private static final char OAUTH2_SCOPE_DELIMITER = ' ';

  @Autowired
  private TokenEndpoint tokenEndpoint;

  @Autowired
  private AccuroOAuthClientLookup clientLookup;

  @Autowired
  private JwtConsumer idpJwtConsumer;

  @Autowired
  private DataSourceService dsService;

  @Autowired
  private AccuroPatientService patientService;

  /**
   * Attempts to validate the office. If successful, returns the office ID.
   *
   * @param ds Data source
   * @param officeId Office ID
   *
   * @return Valid office ID
   *
   * @throws DataAccessException If there has been a database error.
   */
  private static Integer validateOffice(
      DataSource ds,
      Integer officeId)
      throws ProtossException {

    OfficeManager officeManager = new DefaultOfficeManager(ds);
    Set<Office> offices = officeManager.getAllOffices();
    if (officeId == null && offices.size() == 1) {
      return offices.iterator().next().getOfficeId();
    } else if (officeId != null) {
      for (Office office : offices) {
        if (Objects.equals(office.getOfficeId(), officeId)) {
          return officeId;
        }
      }
    }
    return null;
  }

  /**
   * Generates a unique patient-level token based on the supplied office, tenant, and a JWT
   * generated by IDP.
   *
   * @param officeId Office ID
   * @param tenant Unique tenant acronym
   * @param jwtToken Json Web Token
   *
   * @return A patient-level portal token
   *
   * @throws HttpRequestMethodNotSupportedException Request handler does not support a specific
   *         request method.
   * @throws DataAccessException If there has been a database error.
   */
  @POST
  @Path("/token")
  @PreAuthorize("#oauth2.hasScope( 'PORTAL_GENERATE_TOKEN' )")
  @Operation(
      summary = "Retrieves the token",
      description = "Generates the unique patient-level token "
          + "based on the supplied office, tenant, and a JWT generated by IDP.",
      responses = {
          @ApiResponse(
              responseCode = "401",
              description = "Invalid office or client"),
          @ApiResponse(
              responseCode = "500",
              description = "Error accessing newly created IDP account"),
          @ApiResponse(
              responseCode = "200",
              description = "Success",
              content = @Content(schema = @Schema(implementation = PortalToken.class)))})
  @Parameters(
      value = {
          @Parameter(
              name = "authorization",
              description = "Client credentials grant",
              in = ParameterIn.HEADER,
              required = true),
          @Parameter(
              name = "officeId",
              description = "Office id",
              required = true,
              in = ParameterIn.QUERY,
              schema = @Schema(type = "integer")),
          @Parameter(
              name = "tenant",
              description = "Tenant",
              in = ParameterIn.QUERY)})
  @RequestBody(description = "Json Web Token",
      content = @Content(schema = @Schema(type = "string", example = "JSON web token")))
  public PortalToken getToken(
      @Parameter(hidden = true) @QueryParam("officeId") Integer officeId,
      @Parameter(hidden = true) @QueryParam("tenant") String tenant,
      String jwtToken)
      throws HttpRequestMethodNotSupportedException, ProtossException {

    DataSource ds = dsService.getDataSource(tenant);
    Integer validId = validateOffice(ds, officeId);

    if (validId == null) {
      throw Error.webApplicationException(Status.UNAUTHORIZED, "Invalid office");
    }
    String clientId = getOAuthId();
    AccuroOAuthClient client = clientLookup.loadClientByClientId(clientId);

    if (client == null) {
      throw Error.webApplicationException(Status.UNAUTHORIZED, "Invalid client");
    }
    Map<String, String> params = new HashMap<>();
    params.put("client_id", client.getClientId());
    params.put("client_secret", client.getClientSecret());
    params.put("grant_type", "password");
    params.put("scope", StringUtils.join(client.getScope(), OAUTH2_SCOPE_DELIMITER));
    params.put("username", "");
    params.put("password", "");
    params.put("office", validId.toString());
    params.put("tenant", tenant);
    params.put("jwt", jwtToken);

    UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
        client.getClientId(),
        client.getClientSecret()) {
      @Override
      public boolean isAuthenticated() {
        return true;
      }
    };

    final ResponseEntity<OAuth2AccessToken> entity = tokenEndpoint.postAccessToken(auth, params);

    // Get IDP id from token
    Long idpId;
    try {
      idpId = JwtUtil.getIdpUserId(idpJwtConsumer, jwtToken);
    } catch (InvalidJwtException ex) {
      throw Error
          .webApplicationException(Status.INTERNAL_SERVER_ERROR,
              "Error accessing newly created IDP account.", ex);
    }

    Patient patient = patientService.getPatientByIdpUserId(idpId);

    PortalToken portalToken = new PortalToken();
    portalToken.setPatientId(patient.getPatientId());
    portalToken.setFirstName(patient.getDemographics().getFirstName());
    portalToken.setLastName(patient.getDemographics().getLastName());
    portalToken.setMiddleName(patient.getDemographics().getMiddleName());

    EmailDto email = mapDto(patient.getDemographics().getEmail(), EmailDto.class);

    portalToken.setEmail(email);

    List<AddressDto> addresses = mapDto(patient.getDemographics().getAddresses(),
        AddressDto.class,
        ArrayList::new);

    if (addresses != null && !addresses.isEmpty()) {
      portalToken.setAddress(addresses.get(0));
    }
    portalToken.setToken(entity.getBody());

    return portalToken;
  }
}
